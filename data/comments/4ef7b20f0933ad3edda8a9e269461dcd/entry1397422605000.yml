_id: bf39d11b-1f67-374b-9d4b-b416b7ff8879
replyTo: d2691760-b539-36c1-9d37-08bd51f68b5b
name: Chuso
email: 776b9662983df1753c11f85437ffd8d7
url: https://chuso.net
date: 1397422605
message: |
  Hola, Ignacio. Gracias por tu comentario.  
  Sí, estoy al corriente tanto de que el artículo enlazado se ha retractado como del desafío de Cloudflare.  
  En el artículo enlazado se retractan de la explicación que habían dado pero siguen manteniendo que es muy difícil obtener las claves privadas y yo estoy de acuerdo.
  
  Para explicarlo, vamos a recordar por encima en qué consiste Heartbleed: el cliente le dice al servidor que va a enviarle `X` bytes a un servicio echo, es decir, un servicio en el que el servidor le devuelve al cliente la misma información que envió. Por lo tanto, el servidor reserva `X` bytes de memoria. Después, el cliente, en vez de enviarle esos `X` bytes le envia una cantidad `Y&X` y el servidor, al devolverle esos datos, le devuelve todos los `X` bytes que había reservado en vez de los `Y` que el cliente envió, por lo que le envía también la información que había previamente en esa zona de memoria y que no fue sobreescrita con la información enviada por el cliente como se esperaba. Probablemente quede más claro con una [explicación gráfica](https://en.wikipedia.org/wiki/File:Heartbleed_bug_explained.svg).
  
  Bien, teniendo esto en cuenta, ya nos encontramos con la primera restricción: no podemos leer cualquier zona de memoria, solo la memoria que ha sido reservada para los datos que iban a ser enviados al servicio echo de hearbeat hasta un máximo de 64 KB. La vulnerabilidad se encuentra en que esa memoria reservada para hearbeat puede ser memoria que haya sido usada previamente por otros procesos que después la hayan [liberado](http://www.tutorialspoint.com/c_standard_library/c_function_free.htm) y que por lo tanto puedan haber dejado información sensible residual. Esa información se esperaría que fuera sobreescrita con la que envía el usuario, pero, al no comprobarse la discrepancia entre el tamaño efectivo de los datos que envía el usuario y el declarado, se permite que se reserve más memoria de la necesaria que nunca será sobreescrita y que se enviará tal cual al usuario. Aquí tenemos la segunda restricción: solo podemos obtener datos que ya no estén en uso. Y aquí es donde fallaba el artículo de Errata Security ya que decía que era imposible obtener la clave privada porque nunca se liberaba de la memoria. Sería así si, efectivamente, la clave privada nunca se liberase, pero eso no es así.  
  ¿Cuál es la probabilidad de que ningún otro proceso haya sobreescrito la zona de memoria liberada en la que se encontraba la clave privada? ¿Y la de que entre esos 64 KB que reserva hearbeat se encuentre la clave privada? Si por ejemplo tenemos un servidor con 8 GB de RAM, ¿qué probabilidades hay de que seleccionemos un fragmento de 64 KB en el que se encuentre la clave privada y de que no haya sido sobreescrita todavía por ningún proceso? No he hecho las cuentas, pero me da que va a salir una probabilidad bastate pequeña.
  
  <a name="cloudflare"></a>En cuanto al desafío de Cloudflare, el usuario que la consiguió hizo 2,5 millones de intentos siendo el 30% de las peticiones realizadas por todos los usuarios. Es decir, que entre todos los usuarios hicieron 8,3 millones de intentos hasta que se consiguió la clave. Me parece un número de intentos suficientemente alto para seguir considerando que es bastante difícil conseguir la clave privada. Se ha demostrado que es posible, pero yo no he dicho que fuera imposible, solo muy difícil.  
  Por otra parte, la clave privada se obtuvo después de reiniciar el servidor. Ya desde el principio se dijo que hay más probabilidades de obtener la clave privada tras reiniciar el servidor ya que en ese momento es accedida la clave privada y, después de liberar la zona de memoria en la que se encuentra, es más fácil que sea reservada para heartbeat debido a la tendencia de algunas implementaciones de [malloc](https://es.wikipedia.org/wiki/Malloc) a reservar zonas de memoria recientemente liberadas (aunque OpenSSL usa [su propia implementación de malloc](http://article.gmane.org/gmane.os.openbsd.misc/211963) que no sé si influye en este punto) y a que es menos probable que haya sido sobreescrito por otro proceso. Hay que tener en cuenta también que el servidor de Cloudflare estaba destinado exclusivamente a este propósito constando únicamente de una página estática y un formulario de contacto, por lo que tendría muy poca actividad de memoria y era menos probable que la clave privada fuese sobreescrita con datos de otro proceso.
  
  > Eso quiere decir que todo servidor que haya utilizado OpenSSL 1.0.1 _en algún momento de la historia_ está comprometido
  
  ¿Todas las versiones de OpenSSL entre 1.0.1 y 1.0.1f son vulnerables? Lo he respondido en el post.
